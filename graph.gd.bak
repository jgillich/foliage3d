@tool
class_name Foliage3DGraph extends Resource

static var NODES = {
	"Difference": Foliage3DDifference,
	"Prune": Foliage3DPrune,
	"SurfaceSampler": Foliage3DSurfaceSampler,
}

@export var nodes: Array[Dictionary]
@export var connections: Array[Dictionary]


func build_instances() -> Dictionary[String, Foliage3DNode]:
	var instances: Dictionary[String, Foliage3DNode]
	for params in nodes:
		var cls = NODES[params["node"]]
		if cls == null:
			push_error("unknown node %s" % params["node"])
			continue
		var node: Foliage3DNode = cls.new()
		node.set_params(params)
		instances[params["name"]] = node
	return instances


func execute():
	var instances := build_instances()

	for connection in connections:
		var from = instances[connection["from_node"]]
		var to = instances[connection["to_node"]]
		if from == null or to == null:
			push_error("bad node connection")
			return
		to.set_input(from, connection["to_port"])

	# this might be a little resource intensive
	# look into green threads or a fixed thread pool maybe
	var threads: Array[Thread]
	for node in instances.values():
		var thread = Thread.new()
		thread.start(node.execute)
		threads.append(thread)

	for thread in threads:
		thread.wait_to_finish()
